# ===============================================================
# Project Guardian (Debug Edition with Toolbar)
# Unreal Engine 5.6
# ---------------------------------------------------------------
# Adds a top-level Unreal toolbar menu item called "Project Guardian"
# so you can open this audit tool directly from the editor.
# ===============================================================

import unreal
from PySide6.QtWidgets import QApplication, QWidget, QPushButton, QTextEdit, QVBoxLayout, QLabel, QListWidget, QListWidgetItem
from PySide6.QtCore import Qt
import re


# ---------------------------------------------------------------
# 0. Unreal Toolbar Menu
# ---------------------------------------------------------------
class PGToolMenu:
    def __init__(self):
        self.tool_menus = unreal.ToolMenus.get()
        self.menu_owner = "ProjectGuardian"
        self.menu_name = "LevelEditor.MainMenu.ProjectGuardian"
        self.pg_menu = None

    def create_menu(self):
        unreal.log("Creating Project Guardian Menu...")

        # Check if already exists
        existing = self.tool_menus.find_menu(self.menu_name)
        if existing:
            unreal.log("Project Guardian Menu already exists, skipping registration.")
            self.pg_menu = existing
            return

        # Create the menu
        main_menu = self.tool_menus.find_menu("LevelEditor.MainMenu")
        if not main_menu:
            unreal.log_warning("Could not find LevelEditor.MainMenu")
            return

        # Add submenu
        self.pg_menu = main_menu.add_sub_menu(
            owner_name=self.menu_owner,
            section_name="CustomTools",
            name=self.menu_owner,
            label="Project Guardian",
            tool_tip="Audit and Fix Project Assets"
        )

        self.tool_menus.refresh_all_widgets()
        unreal.log("âœ… Project Guardian Menu created.")

    def create_menu_entry(self):
        unreal.log("Creating Project Guardian menu entry...")

        module_name = "ProjectGuardianTool"  # <-- Must match your .py filename!
        command = f"import {module_name}; {module_name}.launch_project_guardian()"

        # Create a new entry that calls our tool
        menu_entry = unreal.ToolMenuEntry(
            name="OpenProjectGuardian",
            type=unreal.MultiBlockType.MENU_ENTRY,
            insert_position=unreal.ToolMenuInsert("", unreal.ToolMenuInsertType.FIRST)
        )
        menu_entry.set_label("Open Project Guardian")
        menu_entry.set_tool_tip("Open the Project Guardian window")
        menu_entry.set_icon("EditorStyle", "Kismet.Tabs.BlueprintDebugger")
        menu_entry.set_string_command(
            type=unreal.ToolMenuStringCommandType.PYTHON,
            string=command
        )

        # Add it into the menu
        self.pg_menu.add_menu_entry("Utils", menu_entry)
        self.tool_menus.refresh_all_widgets()
        unreal.log("âœ… Project Guardian menu entry added.")


# ---------------------------------------------------------------
# 1. UI FIRST (always start with the UI lol)
# ---------------------------------------------------------------

class ProjectGuardianUI(QWidget):
    def __init__(self, controller):
        super().__init__()
        self.controller = controller

        self.setWindowTitle("Project Guardian ðŸ›¡ï¸")
        self.setWindowFlag(Qt.WindowStaysOnTopHint, True)
        self.setMinimumWidth(500)

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("ðŸ” Project Audit Tools"))

        # Buttons
        self.btn_audit = QPushButton("ðŸ”Ž Run Audit")
        self.btn_fix_names = QPushButton("ðŸª„ Auto Fix Names")
        self.btn_enable_nanite = QPushButton("âš¡ Enable Nanite on Meshes")
        self.btn_unused = QPushButton("ðŸ§¹ Find Unused Assets")

        layout.addWidget(self.btn_audit)
        layout.addWidget(self.btn_fix_names)
        layout.addWidget(self.btn_enable_nanite)
        layout.addWidget(self.btn_unused)

        layout.addWidget(QLabel("ðŸ“œ Results"))
        self.results = QListWidget()
        layout.addWidget(self.results)

        layout.addWidget(QLabel("ðŸ“ Log"))
        self.log_box = QTextEdit()
        self.log_box.setReadOnly(True)
        layout.addWidget(self.log_box)

        # Connect events
        self.btn_audit.clicked.connect(self.controller.on_audit)
        self.btn_fix_names.clicked.connect(self.controller.on_fix_names)
        self.btn_enable_nanite.clicked.connect(self.controller.on_enable_nanite)
        self.btn_unused.clicked.connect(self.controller.on_find_unused)

    def add_result(self, text):
        print(f"[DEBUG] Adding result: {text}")
        self.results.addItem(QListWidgetItem(text))

    def log(self, text):
        print(f"[LOG] {text}")
        self.log_box.append(text)

    def clear_results(self):
        print("[DEBUG] Clearing results list")
        self.results.clear()


# ---------------------------------------------------------------
# 2. HELPER FUNCTIONS
# ---------------------------------------------------------------

def build_object_path(asset_data):
    path = f"{asset_data.package_name}.{asset_data.asset_name}"
    print(f"[DEBUG] Built object path: {path}")
    return path


def is_under_game(asset_data):
    check = str(asset_data.package_name).startswith("/Game")
    if not check:
        print(f"[DEBUG] Skipping non-game asset: {asset_data.package_name}")
    return check


def load_asset_safe(asset_path):
    print(f"[DEBUG] Trying to load asset: {asset_path}")
    try:
        return unreal.EditorAssetLibrary.load_asset(asset_path)
    except Exception as e:
        print(f"[ERROR] Could not load asset: {asset_path} -> {e}")
        return None


def is_static_mesh(asset_data):
    try:
        is_mesh = asset_data.asset_class_path.asset_name == "StaticMesh"
        print(f"[DEBUG] {asset_data.asset_name} is mesh: {is_mesh}")
        return is_mesh
    except:
        return False


def bad_name(name):
    if " " in name:
        return "has spaces"
    if name.startswith("New") or name.startswith("Untitled"):
        return "placeholder name"
    if name[0].islower():
        return "starts lowercase"
    return None


def get_prefix_for_class(asset_class):
    print(f"[DEBUG] Getting prefix for class: {asset_class}")
    if "StaticMesh" in asset_class:
        return "SM_"
    elif "MaterialInstance" in asset_class:
        return "MI_"
    elif "Material" in asset_class:
        return "M_"
    elif "Texture" in asset_class:
        return "T_"
    elif "Blueprint" in asset_class:
        return "BP_"
    return "A_"


def clean_name(name):
    print(f"[DEBUG] Cleaning name: {name}")
    name = re.sub(r"[^A-Za-z0-9_]", "_", name)
    return name.replace(" ", "_").title().replace("_", "")


# ---------------------------------------------------------------
# 3. SCAN + FIX FUNCTIONS
# ---------------------------------------------------------------

def find_missing_assets():
    print("[DEBUG] Starting missing asset scan...")
    broken = []
    reg = unreal.AssetRegistryHelpers.get_asset_registry()
    for asset_data in reg.get_all_assets():
        if not is_under_game(asset_data):
            continue
        path = build_object_path(asset_data)
        if not load_asset_safe(path):
            broken.append((path, "Missing / can't load"))
            print(f"[FOUND] Missing asset: {path}")
    print(f"[DEBUG] Done. Found {len(broken)} broken assets.")
    return broken


def find_unused_assets():
    print("[DEBUG] Checking for unused assets...")
    unused = []
    reg = unreal.AssetRegistryHelpers.get_asset_registry()
    for a in reg.get_all_assets():
        if not is_under_game(a):
            continue
        path = build_object_path(a)
        refs = unreal.EditorAssetLibrary.find_package_referencers_for_asset(path)
        if not refs:
            unused.append((path, "Unused asset"))
            print(f"[FOUND] Unused: {path}")
    print(f"[DEBUG] Done. Found {len(unused)} unused assets.")
    return unused


def audit_naming_and_nanite():
    print("[DEBUG] Auditing naming + nanite...")
    bad_names = []
    no_nanite = []
    reg = unreal.AssetRegistryHelpers.get_asset_registry()

    for a in reg.get_all_assets():
        if not is_under_game(a):
            continue
        path = build_object_path(a)

        problem = bad_name(str(a.asset_name))
        if problem:
            bad_names.append((path, f"Naming issue: {problem}"))
            print(f"[FOUND] Bad name: {path}")

        if is_static_mesh(a):
            mesh = load_asset_safe(path)
            if mesh:
                try:
                    settings = mesh.get_editor_property("nanite_settings")
                    if not settings.get_editor_property("enabled"):
                        no_nanite.append((path, "Nanite disabled"))
                        print(f"[FOUND] Nanite disabled: {path}")
                except:
                    print(f"[WARN] Could not check nanite for {path}")
                    no_nanite.append((path, "Nanite check failed"))
    print(f"[DEBUG] Done. Found {len(bad_names)} bad names and {len(no_nanite)} nanite issues.")
    return bad_names, no_nanite


def enable_nanite_everywhere():
    print("[DEBUG] Enabling nanite everywhere...")
    changed = 0
    reg = unreal.AssetRegistryHelpers.get_asset_registry()
    for a in reg.get_all_assets():
        if not is_under_game(a):
            continue
        if not is_static_mesh(a):
            continue
        mesh = load_asset_safe(build_object_path(a))
        if not mesh:
            continue
        try:
            settings = mesh.get_editor_property("nanite_settings")
            if not settings.get_editor_property("enabled"):
                settings.set_editor_property("enabled", True)
                mesh.set_editor_property("nanite_settings", settings)
                unreal.EditorAssetLibrary.save_loaded_asset(mesh)
                changed += 1
                print(f"[UPDATED] Enabled nanite: {a.asset_name}")
        except Exception as e:
            print(f"[ERROR] Nanite enable failed for {a.asset_name}: {e}")
    print(f"[DEBUG] Done. Changed {changed} meshes.")
    return changed


def fix_asset_names():
    print("[DEBUG] Trying to fix asset names...")
    fixed = []
    reg = unreal.AssetRegistryHelpers.get_asset_registry()
    for a in reg.get_all_assets():
        if not is_under_game(a):
            continue

        old_name = str(a.asset_name)
        try:
            asset_class = a.asset_class_path.asset_name
        except:
            asset_class = str(a.asset_class)

        prefix = get_prefix_for_class(str(asset_class))
        if old_name.startswith(prefix):
            continue

        new_name = prefix + clean_name(old_name)
        old_path = build_object_path(a)
        pkg = str(a.package_path)

        try:
            success = unreal.EditorAssetLibrary.rename_asset(old_path, f"{pkg}/{new_name}")
            if success:
                fixed.append((old_name, new_name))
                print(f"[RENAMED] {old_name} â†’ {new_name}")
        except Exception as e:
            print(f"[ERROR] Rename failed: {e}")
    print(f"[DEBUG] Done. Fixed {len(fixed)} names.")
    return fixed


# ---------------------------------------------------------------
# 4. CONTROLLER
# ---------------------------------------------------------------

class ProjectGuardianController:
    def __init__(self):
        print("[DEBUG] Launching Project Guardian...")
        app = QApplication.instance()
        if not app:
            app = QApplication([])
        self.ui = ProjectGuardianUI(self)
        self.ui.show()

    def on_audit(self):
        print("[DEBUG] Starting full audit...")
        self.ui.clear_results()
        self.ui.log("Running audit...")

        missing = find_missing_assets()
        names, nanite = audit_naming_and_nanite()

        if not missing and not names and not nanite:
            self.ui.log("âœ… No major problems found!")
        else:
            for p, issue in missing + names + nanite:
                self.ui.add_result(f"{p}: {issue}")
            self.ui.log("ðŸš¨ Audit done, found issues. Check list.")

    def on_fix_names(self):
        print("[DEBUG] Fixing names...")
        self.ui.log("Trying to fix names...")
        changed = fix_asset_names()
        for old, new in changed:
            self.ui.add_result(f"Renamed {old} â†’ {new}")
        if not changed:
            self.ui.log("âœ¨ Nothing to rename!")

    def on_enable_nanite(self):
        print("[DEBUG] Enabling nanite for all meshes...")
        self.ui.log("Turning Nanite ON...")
        num = enable_nanite_everywhere()
        self.ui.log(f"âœ… Nanite enabled on {num} meshes.")

    def on_find_unused(self):
        print("[DEBUG] Looking for unused assets...")
        self.ui.log("Checking unused assets...")
        unused = find_unused_assets()
        if unused:
            for path, issue in unused:
                self.ui.add_result(f"{path}: {issue}")
        else:
            self.ui.log("âœ… No unused assets found.")


# ---------------------------------------------------------------
# 5. LAUNCHER
# ---------------------------------------------------------------

def launch_project_guardian():
    """Called from Unreal toolbar"""
    ProjectGuardianController()


def setup_menu():
    """Registers the Project Guardian toolbar menu"""
    menu = PGToolMenu()
    menu.create_menu()
    menu.create_menu_entry()


if __name__ == "__main__":
    print("[DEBUG] Setting up Project Guardian...")
    setup_menu()
    launch_project_guardian()
